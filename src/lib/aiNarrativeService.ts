import { NarrativeInput, ModelConfig } from '@/types/narrative.types';
import { narrativeCache } from './narrativeCache';
import { narrativeValidator } from './narrativeValidation';
import { narrativeMetrics } from './narrativeMetrics';
import { getLegalPromptSection } from './legalReferences';

const MODELS: ModelConfig[] = [
  { name: 'gpt-4-turbo-preview', temperature: 0.3, maxTokens: 2000, costPer1K: 0.01 },
  { name: 'gpt-3.5-turbo', temperature: 0.2, maxTokens: 2000, costPer1K: 0.0005 }
];

const DOCUMENT_CONTEXTS: Record<string, { present: string; missing: string }> = {
  cv: {
    present: "The CV demonstrates a comprehensive career history with relevant experience",
    missing: "The absence of a CV prevents verification of claimed experience"
  },
  references: {
    present: "Reference letters provide third-party confirmation of employment",
    missing: "No references were provided to corroborate employment claims"
  },
  payslips: {
    present: "Payslips evidence recent employment and remuneration",
    missing: "Missing payslips create uncertainty about recent employment"
  },
  contracts: {
    present: "Employment contracts confirm the terms and conditions of past roles",
    missing: "Absence of contracts limits verification of employment terms"
  },
  training: {
    present: "Training certificates demonstrate ongoing professional development",
    missing: "No training records provided to evidence skill maintenance"
  }
};

export async function generateAINarrative(input: NarrativeInput, customPrompt?: string): Promise<string> {
  const startTime = Date.now();
  
  // Check cache first
  const cached = narrativeCache.get(input);
  if (cached) {
    console.log('[AI Narrative] Returning cached narrative:', cached);
    return cached;
  }
  
  // Check if we should use AI
  if (!narrativeMetrics.shouldUseAI()) {
    console.log('[AI Narrative] AI generation disabled by experiment, but forcing AI generation for testing');
    // For testing purposes, we'll continue with AI generation
  }
  
  // Try each model in order
  for (const model of MODELS) {
    try {
      console.log('[AI Narrative] Sending request to AI model:', model.name);
      const narrative = await generateWithModel(input, customPrompt);
      const duration = Date.now() - startTime;
      
      // Log the generated narrative and validation result
      console.log('[AI Narrative] Generated narrative:', narrative);
      
      // Validate the output
      const validation = input.riskLevel === 'HIGH' 
        ? narrativeValidator.validateHighRisk(narrative, input)
        : narrativeValidator.validate(narrative, input);
      console.log('[AI Narrative] Validation result:', validation);
      
      if (!validation.isValid) {
        console.error('[AI Narrative] Validation failed:', validation);
        continue; // Try next model
      }
      
      // Cache successful generation
      narrativeCache.set(input, narrative);
      
      // Log metrics
      const tokens = narrativeMetrics.estimateTokens(narrative);
      await narrativeMetrics.logGeneration({
        id: `NAR_${Date.now()}`,
        timestamp: new Date().toISOString(),
        input,
        output: narrative,
        model: model.name,
        promptVersion: '1.0.0',
        temperature: model.temperature,
        duration,
        tokenCount: tokens,
        validationPassed: validation.isValid,
        fallbackUsed: false,
        costEstimate: narrativeMetrics.calculateCost(tokens, model.name)
      });
      
      return narrative;
    } catch (error) {
      console.error(`[AI Narrative] Model ${model.name} failed:`, error);
      continue;
    }
  }
  
  console.log('[AI Narrative] All AI models failed, using fallback/template narrative');
  throw new Error('All AI models failed');
}

async function generateWithModel(input: NarrativeInput, customPrompt?: string): Promise<string> {
  // Build the prompt for AI generation
  const prompt = customPrompt || buildEnhancedPrompt(input);
  
  console.log('[AI Narrative] Using prompt:', prompt);

  try {
    // Import OpenAI dynamically to avoid SSR issues
    const { OpenAI } = await import('openai');
    const openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });

    const completion = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        {
          role: 'system',
          content: prompt
        },
        {
          role: 'user',
          content: `Generate a compliance assessment narrative for worker ${input.workerName} (${input.jobTitle}, SOC ${input.socCode}).`
        }
      ],
      temperature: 0.2,
      max_tokens: 1500,
    });

    const narrative = completion.choices[0]?.message?.content;
    
    if (!narrative) {
      throw new Error('No narrative generated by AI');
    }

    console.log('[AI Narrative] Generated narrative:', narrative);
    return narrative;
  } catch (error) {
    console.error('[AI Narrative] OpenAI API error:', error);
    throw error;
  }
}

function buildEnhancedPrompt(input: NarrativeInput): string {
  // Build document context
  const documentContext = Object.entries({
    cv: input.hasCV,
    references: input.hasReferences,
    payslips: input.hasPayslips,
    contracts: input.hasContracts,
    training: input.hasTraining
  }).map(([type, present]) => {
    return DOCUMENT_CONTEXTS[type][present ? 'present' : 'missing'];
  }).join('\n');
  
  // Determine severity tone
  const severityContext = input.isCompliant 
    ? "Use a professional, acknowledging tone with minor recommendations"
    : input.riskLevel === 'HIGH'
    ? "Use grave concern, emphasize immediate action required and potential consequences"
    : "Use concerned but constructive tone with clear remediation steps";
  
  return `
You are a Senior Immigration Solicitor specializing in UK sponsor compliance.
Generate a formal assessment letter in British legal English.

${getLegalPromptSection()}

TONE REQUIREMENTS:
- Formal, authoritative, professional
- Use "we" (representing the compliance team)
- ${severityContext}
- Include specific legal references
- Clear consequences and actionable recommendations

DOCUMENT EVIDENCE:
${documentContext}

Missing Documents: ${input.missingDocs.join(', ') || 'None'}

DECISION TREE RESULTS:
- Step 1 (Required Documents): ${input.step1Pass ? 'PASS' : 'FAIL'}
- Step 2 (Employment History): ${input.step2Pass ? 'PASS' : 'FAIL'}
- Step 3 (Experience Match): ${input.step3Pass ? 'PASS' : 'FAIL'}
- Step 4 (References): ${input.step4Pass ? 'PASS' : 'FAIL'}
- Step 5 (Recent Experience): ${input.step5Pass ? 'PASS' : 'FAIL'}

Overall: ${input.isCompliant ? 'COMPLIANT' : 'SERIOUS BREACH'}
Risk Level: ${input.riskLevel}

Generate a comprehensive narrative that:
1. Opens with findings summary
2. Details CoS assignment (${input.cosReference} for ${input.workerName})
3. Reviews each decision tree step with specific observations
4. Cites relevant legal breaches if non-compliant
5. Provides clear verdict and recommendations
6. Includes the decision tree summary with ✅/❌ marks

CRITICAL: Base assessment only on provided data. Do not invent details.`;
} 